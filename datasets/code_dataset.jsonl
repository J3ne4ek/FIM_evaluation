{"file_name": "jene4ek/week04-str-bytes-io/simple_cases/simple_cases.py", "context": "def capwords(s: str, sep: str | None = None) -> str:\n    return (sep if sep else \" \").join(\n        [w.capitalize() for w in (s.split(sep) if sep else s.split())]\n    )\ndef cut_suffix(s: str, suffix: str) -> str:\n    return s.rsplit(suffix, 1)[0] if suffix and s.endswith(suffix) else s\ndef boxed(s: str, fill: str, pad: int) -> str:\n    with_spaces = s.center(len(s) + 2)\n    middle_part = with_spaces.center(len(with_spaces) + 2 * pad, fill)\n    return \"\\n\".join([fill * len(middle_part), middle_part, fill * len(middle_part)])\ndef find_all(string: str, pattern: str) -> list[int]:\n    all_index = []\n    index = string.find(pattern)\n    while index != -1:\n        all_index.append(index)\n        index = string.find(pattern, index + 1)\n    return all_index\ndef common_prefix(arg: str, *args: str) -> str:\n    for i in range(len(arg) + 1):\n        if not all(map(lambda x: x.startswith(arg[:i]), args)):\n            return arg[:i - 1]\n    return arg\n"}
{"file_name": "jene4ek/week04-str-bytes-io/rrrider/rrrider.py", "context": "import bz2\nimport gzip\nfrom typing import Any, AnyStr, IO\ndef reader(path: str, **kwargs: Any) -> IO[AnyStr]:\n    if path.endswith(\".gz\"):\n        return gzip.open(path, **kwargs)\n    elif path.endswith(\".bz2\"):\n        return bz2.open(path, **kwargs)\n    else:\n        return open(path, **kwargs)\ndef parse_shebang(path: str) -> str | None:\n    with open(path, \"rb\") as file:\n        first_line = file.readline().rstrip()\n        if first_line.startswith(b\"#!\"):\n            return first_line[2:].decode().strip()\n        return None\n"}
{"file_name": "jene4ek/week04-str-bytes-io/taylor_swift/taylor_swift.py", "context": "import random\nfrom collections.abc import Iterable\ndef words(handle: Iterable[str]) -> list[str]:\n    return [word for line in handle for word in line.split(\" \")]\ndef transition_matrix(language: list[str]) -> dict[tuple[str, str], list[str]]:\n    transitions: dict[tuple[str, str], list[str]] = dict()\n    for first, second, third in zip(language, language[1:], language[2:]):\n        key = (first, second)\n        if key in transitions.keys():\n            transitions[key].append(third)\n        else:\n            transitions[key] = [third]\n    return transitions\ndef markov_chain(\n    language: list[str], m: dict[tuple[str, str], list[str]], size: int\n) -> str:\n    words: list[str] = []\n    for i in range(size):\n        if len(words) < 2 or (words[-2], words[-1]) not in m:\n            words.append(random.choice(language))\n        else:\n            words.append(random.choice(m[(words[-2], words[-1])]))\n    return \" \".join(words)\ndef taylor_swift(path: str, size: int) -> str:\n    with open(path) as f:\n        language = words(f)\n    m = transition_matrix(language)\n    return markov_chain(language, m, size)\n"}
{"file_name": "jene4ek/week05-collections/typos/typos.py", "context": "from collections import Counter\nfrom typing import Any\ndef export_graph(g: dict[int, list[int]], words: list[str]) -> str:\n    graph = \"graph {\\n\"\n    for v, edges in g.items():\n        graph += f\"{v} [label=\\\"{words[v]}\\\"]\\n\"\n        for e in edges:\n            if e > v:\n                graph += f\"{v} -- {e}\\n\"\n    graph += \"}\"\n    return graph\ndef find_connected_components(g: dict[int, list[int]]) -> list[set[int]]:\n    visited = set()\n    connected_components = []\n    def dfs(v: int, comp: set[int]) -> None:\n        visited.add(v)\n        comp.add(v)\n"}
{"file_name": "jene4ek/week05-collections/typos/typos.py", "context": "        for u in g[v]:\n            if u not in visited:\n                dfs(u, comp)\n    for v in g:\n        if v not in visited:\n            comp: set[int] = set()\n            dfs(v, comp)\n            connected_components.append(comp)\n    return connected_components\ndef find_consensus(words: list[str]) -> str:\n    consensus = \"\"\n    for i in range(len(words[0])):\n        counter = Counter(word[i] for word in words)\n        consensus += counter.most_common(1)[0][0]\n    return consensus\ndef hamming(s1: str, s2: str) -> float:\n    return sum(c1 != c2 for c1, c2 in zip(s1, s2))\n"}
{"file_name": "jene4ek/week05-collections/typos/typos.py", "context": "def build_graph(words: list[str], mismatch_percent: float) -> dict[int, list[int]]:\n    graph: dict[int, list[int]] = {i: [] for i in range(len(words))}\n    for i, s1 in enumerate(words):\n        for j in range(i + 1, len(words)):\n            s2 = words[j]\n            max_miss = int(len(s1) * mismatch_percent / 100)\n            if len(s1) == len(s2) and hamming(s1, s2) <= max_miss:\n                graph[i].append(j)\n                graph[j].append(i)\n    return graph\ndef correct_typos(words: list[str], **kwargs: Any) -> list[str]:\n    g = build_graph(words, kwargs[\"mismatch_percent\"])\n    components = find_connected_components(g)\n    right_words = words.copy()\n    for c in components:\n        consensus = find_consensus([words[v] for v in c])\n        for v in c:\n"}
{"file_name": "jene4ek/week05-collections/lru_cache/lru_cache.py", "context": "from functools import wraps\nfrom collections import OrderedDict\nfrom collections.abc import Callable\nfrom typing import TypeVar, ParamSpec, Protocol, cast, NamedTuple\nP = ParamSpec('P')\nT = TypeVar('T')\nK = TypeVar('K')\nT_co = TypeVar('T_co', covariant=True)\nclass CacheInfo(NamedTuple):\n    hits: int\n    misses: int\n    maxsize: int\n    currsize: int\nclass CachedCallable(Protocol[P, T_co]):\n    cache_clear: Callable[[], None]\n    cache_info: Callable[[], CacheInfo]\n    def __call__(self, *args: P.args) -> T_co:\n"}
{"file_name": "jene4ek/week05-collections/lru_cache/lru_cache.py", "context": "        ...\ndef cached_callable(func: Callable[P, T]) -> CachedCallable[P, T]:\n    return cast('CachedCallable[P, T]', func)\ndef lru_cache(func: Callable[P, T] | None = None, *, maxsize: int = 64) -> CachedCallable[P, T]:\n    if func is None:\n        return cast('CachedCallable[P, T]', lambda func_: lru_cache(func_, maxsize=maxsize))\n    cache: OrderedDict[P.args, T] = OrderedDict()\n    hits = 0\n    misses = 0\n    @wraps(func)\n    @cached_callable\n    def inner(*args: P.args) -> T:\n        nonlocal hits, misses\n        if args in cache:\n            hits += 1\n            result = cache[args]\n            cache.move_to_end(args, last=True)\n"}
{"file_name": "jene4ek/week05-collections/lru_cache/lru_cache.py", "context": "        else:\n            misses += 1\n            assert func is not None\n            result = func(*args)\n            cache[args] = result\n            if len(cache) > maxsize:\n                cache.popitem(last=False)\n        return result\n    def cache_clear() -> None:\n        nonlocal cache, hits, misses\n        cache.clear()\n        hits = 0\n        misses = 0\n    inner.cache_clear = cache_clear\n    inner.cache_info = lambda: CacheInfo(hits=hits, misses=misses,\n                                         maxsize=maxsize, currsize=len(cache))\n    return cast('CachedCallable[P, T]', inner)\n"}
{"file_name": "jene4ek/week05-collections/collect_it/collect_it.py", "context": "from collections import defaultdict, namedtuple, OrderedDict\nfrom collections.abc import Callable, Iterable\nfrom typing import TypeVar, ParamSpec\nFactor = namedtuple(\"Factor\", [\"elements\", \"levels\"])\nP = ParamSpec('P')\nT = TypeVar('T')\nK = TypeVar('K')\nT_co = TypeVar('T_co', covariant=True)\ndef factor(xs: list[str]) -> Factor:\n    levels: OrderedDict[str, int] = OrderedDict()\n    for x in xs:\n        if x not in levels:\n            levels[x] = len(levels)\n    return Factor(elements=[levels[x] for x in xs], levels=levels)\ndef group_by(iterable: Iterable[T], key: Callable[[T], K]) -> defaultdict[K, list[T]]:\n    grouped_dict = defaultdict(list)\n    for item in iterable:\n        grouped_dict[key(item)].append(item)\n    return grouped_dict\ndef invert(dict_: dict[T, K]) -> defaultdict[K, set[T]]:\n    inverted_dict = defaultdict(set)\n    for key, value in dict_.items():\n        inverted_dict[value].add(key)\n    return inverted_dict\n"}
{"file_name": "jene4ek/week10-classes-201/undodict/undodict.py", "context": "from collections.abc import MutableMapping, Iterator\nfrom typing import Optional, TypeVar, Generic\nKT = TypeVar(\"KT\")\nVT = TypeVar(\"VT\")\nclass SetCommand(Generic[KT, VT]):\n    def __init__(self, key: KT, value: VT):\n        self.key = key\n        self.value = value\n    def __call__(\n        self, data: \"MutableMapping[KT, VT]\"\n    ) -> \"SetCommand[KT, VT] | DelCommand[KT, VT]\":\n        old_value = data.get(self.key)\n        data[self.key] = self.value\n        return (\n            DelCommand(self.key)\n            if old_value is None\n            else SetCommand(self.key, old_value)\n"}
{"file_name": "jene4ek/week10-classes-201/undodict/undodict.py", "context": "        )\nclass DelCommand(Generic[KT, VT]):\n    def __init__(self, key: KT):\n        self.key = key\n    def __call__(self, data: \"MutableMapping[KT, VT]\") -> \"SetCommand[KT, VT]\":\n        value = data.pop(self.key)\n        return SetCommand(self.key, value)\nclass UndoDict(MutableMapping[KT, VT]):\n    def __init__(self, initial: Optional[MutableMapping[KT, VT]] = None):\n        self._data = initial or {}  # the initial version of the dict.\n        self._undo_log: list[SetCommand[KT, VT] | DelCommand[KT, VT]] = []\n        self._redo_log: list[SetCommand[KT, VT] | DelCommand[KT, VT]] = []\n    def __str__(self) -> str:\n        return str(self._data)\n    def __repr__(self) -> str:\n        return repr(self._data)\n    def __getitem__(self, key: KT) -> VT:\n"}
{"file_name": "jene4ek/week10-classes-201/undodict/undodict.py", "context": "        return self._data[key]\n    def __setitem__(self, key: KT, value: VT) -> None:\n        set_command: SetCommand[KT, VT] = SetCommand(key, value)\n        self._undo_log.append(set_command(self._data))\n        self._redo_log.clear()\n    def __delitem__(self, key: KT) -> None:\n        del_command: DelCommand[KT, VT] = DelCommand(key)\n        self._undo_log.append(del_command(self._data))\n        self._redo_log.clear()\n    def __iter__(self) -> Iterator[KT]:\n        return iter(self._data)\n    def __len__(self) -> int:\n        return len(self._data)\n    def undo(self) -> None:\n        command = self._undo_log.pop()\n        self._redo_log.append(command(self._data))\n    def redo(self) -> None:\n"}
{"file_name": "jene4ek/week10-classes-201/structure/structure.py", "context": "import abc\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping, Iterable\nfrom typing import Any, TypeVar, Generic, Self, Optional\nT = TypeVar(\"T\")\nclass Field(abc.ABC, Generic[T]):\n    def __init__(self, name: str | None = None) -> None:\n        self.name = name\n    def __get__(self, instance: Any, owner: Optional[type]) -> Self:\n        if instance is None:\n            return self\n        if self.name not in instance.__dict__:\n            raise AttributeError()\n        return instance.__dict__[self.name]\n    def __set__(self, instance: Any, value: Any) -> None:\n        self.clean(value)\n        instance.__dict__[self.name] = value\n"}
{"file_name": "jene4ek/week10-classes-201/structure/structure.py", "context": "    def __delete__(self, instance: Any) -> None:\n        if self.name not in instance.__dict__:\n            raise AttributeError()\n        del instance.__dict__[self.name]\n    def __set_name__(self, owner: type, name: str) -> None:\n        if self.name is None:\n            self.name = name\n    @abc.abstractmethod\n    def clean(self, value: T) -> T:\n        return value\nclass StringField(Field[str]):\n    def clean(self, value: str) -> str:\n        if not isinstance(value, str):\n            raise ValueError(\"Value must be a string\")\n        return value\nclass IntegerField(Field[int]):\n    def __init__(self, *args: Any, min_value: int, max_value: int, **kwargs: Any):\n"}
{"file_name": "jene4ek/week10-classes-201/structure/structure.py", "context": "        super().__init__(*args, **kwargs)\n        self.min_value = min_value\n        self.max_value = max_value\n    def clean(self, value: int) -> int:\n        if (\n            not isinstance(value, int)\n            or value < self.min_value\n            or value > self.max_value\n        ):\n            raise ValueError(\n                f\"{value} must be in [{self.min_value}, {self.max_value}]\"\n            )\n        return value\nclass ChoiceField(Field[str]):\n    def __init__(self, *args: Any, choices: Iterable[str], **kwargs: Any):\n        super().__init__(*args, **kwargs)\n        self.choices = choices or set()\n"}
{"file_name": "jene4ek/week10-classes-201/structure/structure.py", "context": "    def clean(self, value: str) -> str:\n        if value not in self.choices:\n            raise ValueError(\n                f\"{value} must be one of {', '.join(map(str, self.choices))}\"\n            )\n        return value\nclass StructMeta(type):\n    def __new__(\n        metacls, name: str, bases: tuple[type, ...], clsdict: dict[str, Any]\n    ) -> type:\n        fields = [key for key, value in clsdict.items() if isinstance(value, Field)]\n        if fields:\n            args = \", \".join(f\"{field}\" for field in fields)\n            body = \"\\n\".join(f\"    self.{field} = {field}\" for field in fields)\n            func = f\"def __init__(self, {args}):\\n{body}\\n\"\n            res: dict[str, Any] = {}\n            exec(func, res)\n"}
{"file_name": "jene4ek/week10-classes-201/structure/structure.py", "context": "            clsdict[\"__init__\"] = res[\"__init__\"]\n        cls = super().__new__(metacls, name, bases, clsdict)\n        return cls\n    @classmethod\n    def __prepare__(\n        metacls, name: str, bases: tuple[type, ...], /, **kwargs: Any\n    ) -> MutableMapping[str, object]:\n        return OrderedDict()\nclass Struct(metaclass=StructMeta):\n    pass\n"}
{"file_name": "jene4ek/week06-classes-101/interface/interface.py", "context": "from collections.abc import Callable\nfrom typing import TypeVar\nT = TypeVar(\"T\")\nU = TypeVar(\"U\")\ndef peel(cls: T) -> set[str]:\n    return set(m for m in dir(cls) if not m.startswith(\"_\"))\ndef implements(interface: T) -> Callable[[U], U]:\n    def decorator(cls: U) -> U:\n        interface_methods = peel(interface)\n        cls_methods = peel(cls)\n        assert not (interface_methods - cls_methods), \"Not all methods are implemented\"\n        return cls\n    return decorator\n"}
{"file_name": "jene4ek/week06-classes-101/differentiation/differentiation.py", "context": "from typing import no_type_check\n# NOTE: You allowed to place @no_type_check decorator and/or place \"# type: ignore\" comments\n@no_type_check\nclass Expr:\n    def __call__(self, **context) -> float: # type: ignore\n        raise NotImplementedError(\"Must be implemented by subclass\")\n    def d(self, wrt): # type: ignore\n        raise NotImplementedError(\"Must be implemented by subclass\")\n    def __repr__(self) -> str:\n        raise NotImplementedError(\"Must be implemented by subclass\")\n    def __neg__(self): # type: ignore\n        return Product(Const(-1), self)\n    def __pos__(self): # type: ignore\n        return Product(Const(1), self)\n    def __add__(self, other): # type: ignore\n        return Sum(self, other)\n    def __sub__(self, other): # type: ignore\n"}
{"file_name": "jene4ek/week06-classes-101/differentiation/differentiation.py", "context": "        return Sum(self, Product(Const(-1), other))\n    def __mul__(self, other): # type: ignore\n        return Product(self, other)\n    def __truediv__(self, other): # type: ignore\n        return Fraction(self, other)\n    def __pow__(self, other): # type: ignore\n        return Power(self, other)\n    @property\n    def is_constexpr(self) -> bool:\n        raise NotImplementedError(\"Must be implemented by subclass\")\n    @property\n    def simplified(self): # type: ignore\n        raise NotImplementedError(\"Must be implemented by subclass\")\nclass Const(Expr):\n    def __init__(self, value: float) -> None:\n        self.value = value\n    def __call__(self, **context) -> float: # type: ignore\n"}
{"file_name": "jene4ek/week06-classes-101/differentiation/differentiation.py", "context": "        return self.value\n    def __repr__(self) -> str:\n        return f\"Const({self.value})\"\n    def __str__(self) -> str:\n        return str(self.value)\n    def d(self, wrt: Expr) -> Expr: # type: ignore\n        return Const(0)\n    @property\n    def is_constexpr(self) -> bool:\n        return True\n    @property\n    def simplified(self) -> Expr:\n        return self\nclass Var(Expr):\n    def __init__(self, name: str):\n        self.name = name\n    def __call__(self, **context) -> float: # type: ignore\n"}
{"file_name": "jene4ek/week06-classes-101/differentiation/differentiation.py", "context": "        return context[self.name]\n    def __repr__(self) -> str:\n        return f\"Var('{self.name}')\"\n    def __str__(self) -> str:\n        return self.name\n    def d(self, wrt) -> Expr: # type: ignore\n        if self.name == wrt.name:\n            return Const(1)\n        else:\n            return Const(0)\n    @property\n    def is_constexpr(self) -> bool:\n        return False\n    @property\n    def simplified(self) -> Expr:\n        return self\nclass BinOp(Expr):\n"}
{"file_name": "jene4ek/week06-classes-101/differentiation/differentiation.py", "context": "    def __init__(self, expr1: Expr, expr2: Expr):\n        self.expr1 = expr1\n        self.expr2 = expr2\n    def __str__(self) -> str:\n        return f\"({self.operation} {self.expr1} {self.expr2})\"\n    def __repr__(self) -> str:\n        return f\"{self.name}({self.expr1.__repr__()}, {self.expr2.__repr__()})\"\n    @property\n    def operation(self) -> str:\n        raise NotImplementedError(\"Must be implemented by subclass\")\n    @property\n    def name(self) -> str:\n        raise NotImplementedError(\"Must be implemented by subclass\")\n    @property\n    def is_constexpr(self) -> bool:\n        return self.expr1.is_constexpr and self.expr2.is_constexpr\n    @property\n"}
{"file_name": "jene4ek/week06-classes-101/differentiation/differentiation.py", "context": "    def simplified(self) -> Expr:\n        if self.expr1.is_constexpr and self.expr2.is_constexpr:\n            return Const(self())\n        return self.__class__(self.expr1.simplified, self.expr2.simplified)\nclass Sum(BinOp):\n    def __call__(self, **context) -> float: # type: ignore\n        return self.expr1(**context) + self.expr2(**context)\n    def d(self, wrt: Expr) -> Expr:\n        return Sum(self.expr1.d(wrt), self.expr2.d(wrt))\n    @property\n    def operation(self) -> str:\n        return '+'\n    @property\n    def name(self) -> str:\n        return \"Sum\"\nclass Product(BinOp):\n    def __call__(self, **context) -> float: # type: ignore\n"}
{"file_name": "jene4ek/week06-classes-101/differentiation/differentiation.py", "context": "        return self.expr1(**context) * self.expr2(**context)\n    def d(self, wrt: Expr) -> Expr:\n        return Sum(Product(self.expr1.d(wrt), self.expr2), Product(self.expr1, self.expr2.d(wrt)))\n    @property\n    def operation(self) -> str:\n        return '*'\n    @property\n    def name(self) -> str:\n        return \"Product\"\nclass Fraction(BinOp):\n    def __call__(self, **context) -> float: # type: ignore\n        return self.expr1(**context) / self.expr2(**context)\n    def d(self, wrt) -> Expr: # type: ignore\n        num = Sum(Product(self.expr1.d(wrt), self.expr2), Product(Const(-1), Product(self.expr1, self.expr2.d(wrt))))\n        denom = Product(self.expr2, self.expr2)\n        return Fraction(num, denom)\n    @property\n"}
{"file_name": "jene4ek/week06-classes-101/differentiation/differentiation.py", "context": "    def operation(self) -> str:\n        return '/'\n    @property\n    def name(self) -> str:\n        return \"Fraction\"\nclass Power(BinOp):\n    def __call__(self, **context) -> float: # type: ignore\n        return self.expr1(**context) ** self.expr2(**context)\n    def d(self, wrt: Expr) -> Expr:\n        base = self.expr1\n        exponent = self.expr2\n        return Product(Product(exponent, Power(base, Sum(exponent, Const(-1)))), base.d(wrt))\n    @property\n    def operation(self) -> str:\n        return '**'\n    @property\n    def name(self) -> str:\n"}
{"file_name": "jene4ek/week06-classes-101/differentiation/differentiation.py", "context": "        return \"Power\"\ndef newton_raphson(fexpr: Expr, xi: float, threshold: float = 1e-4) -> float:\n    formula = Var(\"x\") - fexpr / fexpr.d(Var(\"x\"))\n    old_xi = float('inf')\n    while abs(xi - old_xi) > threshold:\n        old_xi = xi\n        xi = formula(x=xi)\n    return xi\n"}
{"file_name": "jene4ek/week08-itertools/reitertools/reitertools.py", "context": "import itertools\nfrom collections.abc import Callable, Iterable, Iterator\nfrom typing import TypeVar, Any\nT = TypeVar(\"T\")\ndef ilen(iterable: Iterable[Any]) -> int:\n    return sum(1 for _ in iterable)\ndef find(p: Callable[[T], bool], iterable: Iterable[T]) -> T:\n    try:\n        return next(x for x in iterable if p(x))\n    except StopIteration:\n        raise ValueError(\"not found\")\ndef chunked(iterable: Iterable[T], n: int) -> Iterator[Iterable[T]]:\n    for chunk in itertools.batched(iterable, n):\n        yield chunk\ndef rle(iterable: Iterable[T]) -> Iterator[tuple[T, int]]:\n    for key, v in itertools.groupby(iterable):\n        yield key, ilen(v)\n"}
{"file_name": "jene4ek/week08-itertools/iterators/iterators.py", "context": "import itertools\nfrom collections.abc import Iterable, Iterator\nfrom typing import TypeVar, Generic, Self, Optional\nT = TypeVar(\"T\")\ndef intersperse(sep: T, xs: Iterable[T]) -> Iterator[T]:\n    first = True\n    for item in xs:\n        if not first:\n            yield sep\n        first = False\n        yield item\nclass peekable(Generic[T]):\n    def __init__(self, iterable: Iterable[T]):\n        self.it: Iterator[T] = iter(iterable)\n        self.peeked: Optional[T] = None\n        self.has_peeked: bool = False\n    def __iter__(self) -> Self:\n"}
{"file_name": "jene4ek/week08-itertools/iterators/iterators.py", "context": "        return self\n    def __next__(self) -> Optional[T]:\n        if not self.has_peeked:\n            return next(self.it)\n        self.has_peeked = False\n        return self.peeked\n    def peek(self) -> Optional[T]:\n        if not self.has_peeked:\n            self.has_peeked = True\n            self.peeked = next(self.it)\n        return self.peeked\ndef padded(iterable: Iterable[T], n: int, default: T) -> Iterator[T]:\n    padded_iterable = itertools.chain(iterable, itertools.repeat(default))\n    return itertools.islice(padded_iterable, n)\ndef sliding(iterable: Iterable[T], n: int, step: int) -> Iterator[Iterable[T]]:\n    it = iter(iterable)\n    first = list(itertools.islice(it, n))\n"}
{"file_name": "jene4ek/week08-itertools/iterators/iterators.py", "context": "    prev = first[step:]\n    if len(first) == n:\n        yield first\n    for new_values in itertools.batched(it, step):\n        new_elements = prev + list(new_values)\n        prev = new_elements[step:]\n        if len(new_elements) < n:\n            break\n        yield new_elements\n"}
{"file_name": "jene4ek/week03-decorators/decorators_1/decorators_1.py", "context": "from collections.abc import Callable\nfrom functools import reduce\nfrom typing import TypeVar, ParamSpec\nP = ParamSpec(\"P\")\nT = TypeVar(\"T\")\nT_cov = TypeVar(\"T_cov\", covariant=True)\ndef union(*sets: set[T]) -> set[T]:\n    return reduce(lambda a, b: a | b, sets, set())\ndef digits(n: int) -> list[int]:\n    return [n] if n < 9 else digits(n // 10) + [n % 10]\ndef lcm(arg1: int, arg2: int, *rest: int) -> int:\n    def gcd(a: int, b: int) -> int:\n        while b != 0:\n            a, b = b, a % b\n        return a\n    arg2 = arg2 if not rest else lcm(arg2, *rest)\n    return (arg1 * arg2) // gcd(arg1, arg2)\ndef compose(*fns: Callable[[int], int]) -> Callable[[int], int]:\n    def two_compose(f: Callable[[int], int], g: Callable[[int], int]) -> Callable[[int], int]:\n        return lambda x: f(g(x))\n    return reduce(two_compose, fns)\n"}
{"file_name": "jene4ek/week03-decorators/pyke/pyke.py", "context": "from collections.abc import Callable\nfrom functools import wraps\nfrom typing import TypeVar, ParamSpec, Optional, cast, Protocol, no_type_check\nP = ParamSpec(\"P\")\nT = TypeVar(\"T\")\nT_cov = TypeVar(\"T_cov\", covariant=True)\nclass Task(Protocol):\n    get_dependencies: Callable[[], list[str]]\n    def __call__(self) -> None:\n        ...\nclass Register(Protocol):\n    get_all: Callable[[], list[str]]\n    def __call__(\n            self,\n            func: Optional[Callable[[], None]] = None,\n            *,\n            depends_on: Optional[list[str]] = None\n"}
{"file_name": "jene4ek/week03-decorators/pyke/pyke.py", "context": "    ) -> Task:\n        ...\n@no_type_check  # you do not have to write type hints for this task\ndef project() -> Register:\n    tasks = {}\n    def register(func=None, depends_on=None):\n        if func is None:\n            return lambda func_: register(func_, depends_on=depends_on)\n        tasks[func.__name__] = func\n        func.get_dependencies = lambda: depends_on if depends_on else []\n        func.called = False\n        @wraps(func)\n        def inner():\n            def init_dependencies(task_name_):\n                for dependency in tasks[task_name_].get_dependencies():\n                    if not tasks[dependency].called:\n                        init_dependencies(dependency)\n"}
{"file_name": "jene4ek/week03-decorators/pyke/pyke.py", "context": "                        tasks[dependency]()\n                        tasks[dependency].called = True\n            def clean_calls(task_name_):\n                for dependency in tasks[task_name_].get_dependencies():\n                    tasks[dependency].called = False\n                    clean_calls(dependency)\n            init_dependencies(func.__name__)\n            clean_calls(func.__name__)\n            func()\n        return inner\n    register.get_all = lambda: list(tasks.keys())\n    return cast(Register, register)\n"}
{"file_name": "jene4ek/week03-decorators/decorators_2/decorators_2.py", "context": "from collections.abc import Callable\nfrom functools import wraps\nfrom typing import TypeVar, ParamSpec, cast, Protocol\nP = ParamSpec(\"P\")\nT = TypeVar(\"T\")\nT_cov = TypeVar(\"T_cov\", covariant=True)\nclass CalledCallable(Protocol[P, T]):\n    called: bool\n    result: T\n    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> T:\n        ...\ndef called_callable(func: Callable[P, T]) -> CalledCallable[P, T]:\n    return cast('CalledCallable[P, T]', func)\ndef once(func: Callable[P, T]) -> Callable[P, T]:\n    @wraps(func)\n    @called_callable\n    def inner(*args: P.args, **kwargs: P.kwargs) -> T:\n"}
{"file_name": "jene4ek/week03-decorators/decorators_2/decorators_2.py", "context": "        if not inner.called:\n            inner.called = True\n            inner.result = func(*args, **kwargs)\n        return inner.result\n    inner.called = False\n    return inner\ndef trace_if(cond: Callable[P, bool]) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @wraps(func)\n        def inner(*args: P.args, **kwargs: P.kwargs) -> T:\n            if cond(*args, **kwargs):\n                print(func.__name__, args, kwargs)\n            return func(*args, **kwargs)\n        return inner\n    return decorator\ndef n_times(n: int) -> Callable[[Callable[P, T]], Callable[P, None]]:\n    def decorator(func: Callable[P, T]) -> Callable[P, None]:\n"}
{"file_name": "jene4ek/week03-decorators/decorators_2/decorators_2.py", "context": "        @wraps(func)\n        def inner(*args: P.args, **kwargs: P.kwargs) -> None:\n            for _ in range(n):\n                func(*args, **kwargs)\n        return inner\n    return decorator\n"}
{"file_name": "jene4ek/week07-exceptions-with/context/context.py", "context": "import sys\nimport traceback\nfrom collections.abc import Callable\nfrom functools import wraps\nfrom types import TracebackType\nfrom typing import Optional, Type, Protocol, ParamSpec, TypeVar, Any, TextIO\nclass Closeable(Protocol):\n    def close(self) -> None:\n        ...\nP = ParamSpec(\"P\")\nT = TypeVar(\"T\")\nclass assert_raises:\n    def __init__(self, exception: Type[BaseException]) -> None:\n        self.exception = exception\n    def __enter__(self) -> None:\n        pass\n    def __exit__(self, exc_type: Type[BaseException], exc_val: BaseException, tb: Optional[TracebackType]) -> bool:\n"}
{"file_name": "jene4ek/week07-exceptions-with/context/context.py", "context": "        if exc_type is None:\n            raise AssertionError(\"did not raise '{}'\".format(self.exception.__name__))\n        return issubclass(exc_type, self.exception)\nclass closing:\n    def __init__(self, file: Closeable):\n        self.file = file\n    def __enter__(self) -> Closeable:\n        return self.file\n    def __exit__(self, *exc_info: Optional[tuple[Type[BaseException], BaseException, Optional[TracebackType]]]) -> None:\n        self.file.close()\nclass print_exceptions:\n    def __init__(self, file: Optional[TextIO] = None) -> None:\n        self.file = file or sys.stderr\n    def __enter__(self) -> None:\n        pass\n    def __exit__(self, exc_type: Type[BaseException], exc_val: BaseException, tb: Optional[TracebackType]) -> bool:\n        if exc_type:\n"}
{"file_name": "jene4ek/week07-exceptions-with/context/context.py", "context": "            traceback.print_exception(exc_type, value=exc_val, tb=tb, file=self.file)\n            return True\n        return True\ndef with_context(context_manager: Any) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            with context_manager:\n                return func(*args, **kwargs)\n        return wrapper\n    return decorator\n"}
{"file_name": "jene4ek/week07-exceptions-with/http_get/http_get.py", "context": "import time\nimport timeit\nfrom urllib.error import HTTPError\nfrom urllib.request import urlopen\nclass ExceededRetries(Exception):\n    def __init__(self, time_elapsed: float) -> None:\n        self.time = time_elapsed\n        super().__init__(\"Exceeded retries\")\ndef robust_get(url: str) -> int:\n    attempts = 5\n    time_start = timeit.default_timer()\n    for _ in range(attempts):\n        try:\n            with urlopen(url):\n                return 0\n        except HTTPError:\n            time.sleep(1)\n    time_end = timeit.default_timer()\n    raise ExceededRetries(time_end - time_start)\n"}
